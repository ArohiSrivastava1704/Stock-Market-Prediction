# -*- coding: utf-8 -*-
"""Stock_Market_Infosys2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Hv91OEYO4E0mKVXrBolaOh_eLlkw9Ujh
"""

# Importing Libraries

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import warnings
warnings.filterwarnings('ignore')

from google.colab import files
uploaded = files.upload()

"""**Data Preprocessing**"""

# Loading Dataset


data = pd.read_csv('Infosys_Stock_Data.csv')

# View the first few rows

data.head()

# View the last 10 rows

data.tail(10)

# Check the shape of dataset

data.shape

# View the columns

data.columns

# Check the data types of dataset

data.dtypes

# Basic information about the dataset

print("\nDataset Overview: \n")
print(data.info())

# Check for missing values

print("\nMissing Values: \n")
print(data.isnull().sum())

# Visualizing missing data

# Import library
import missingno as msno
msno.matrix(data)
plt.show()

# Converting date column into datetime formate

data['Date'] = pd.to_datetime(data['Date'])

# Identifying dataframe containing stock price between what dates and how many days

print(f" Dataframe contain Stock price between : {data['Date'].min()} {data['Date'].max()} ")
print(f" Total days : {(data.Date.max()-data.Date.min()).days} days ")

# Describe statistics of dataset

print("\nDescriptive Statistics: \n")
print(data.describe())

"""**EDA - Exploratory Data Analysis**"""

# Line plot for price Trends
# Assuming the dataset has columns: 'Date', 'Close'

data.sort_values('Date', inplace=True)

plt.figure(figsize=(14, 7))
plt.plot(data['Date'], data['Close'], label='Closing Price')
plt.title('Stock Closing Price Over Time')
plt.xlabel('Date')
plt.ylabel('Closing Price')
plt.legend()
plt.grid()
plt.show()

# Histogram for distribution of Closing Prices

plt.figure(figsize=(10, 5))
sns.histplot(data["Close"], bins=30, kde=True, color="Skyblue")
plt.title("Distribution of Closing Prices")
plt.xlabel("Closing Price (INR)")
plt.ylabel("Frequency")
plt.show()

# Box plots for checking Outliers

data[['Close']].plot(kind='box', vert=False, figsize=(8,4))
plt.show()

# Calculate Moving Averages

data['SMA_20'] = data['Close'].rolling(window=20).mean()  # 20-day Simple Moving Average
data['SMA_50'] = data['Close'].rolling(window=50).mean()  # 50-day Simple Moving Average
data['SMA_100'] = data['Close'].rolling(window=100).mean()  # 100-day Simple Moving Average

# Plotting Moving Averages

plt.figure(figsize=(14, 7))
plt.plot(data['Date'], data['Close'], label='Close Price', alpha=0.5)
plt.plot(data['Date'], data['SMA_20'], label='20-Day SMA', color='green')
plt.plot(data['Date'], data['SMA_50'], label='50-Day SMA', color='red')
plt.plot(data['Date'], data['SMA_100'], label='100-Day SMA', color='y')
plt.title('Moving Averages')
plt.xlabel('Date')
plt.ylabel('Price')
plt.legend()
plt.grid()
plt.show()

data.head()

# Correlation Heatmap

plt.figure(figsize=(8, 6))
sns.heatmap(data.corr(), annot=True, cmap='coolwarm')
plt.title('Correlation Heatmap')
plt.show()

# Create lag features

data['Lag_1'] = data['Close'].shift(1)
data['Lag_2'] = data['Close'].shift(2)
data['Lag_3'] = data['Close'].shift(3)

# Calculate daily returns

data['Daily_Return'] = data['Close'].pct_change()

# Plotting Daily Returns

plt.figure(figsize=(14, 7))
plt.plot(data['Date'], data['Daily_Return'], label='Daily Returns')
plt.axhline(0, color='red', linestyle='--', linewidth=1)
plt.title('Daily Returns Over Time')
plt.xlabel('Date')
plt.ylabel('Daily Return')
plt.legend()
plt.grid()
plt.show()

"""Model Building"""

import pandas as pd
import numpy as np
from statsmodels.tsa.arima.model import ARIMA
from statsmodels.tsa.statespace.sarimax import SARIMAX
from sklearn.metrics import mean_squared_error, mean_absolute_error
import prophet
from prophet import Prophet
import matplotlib.pyplot as plt
from keras.models import Sequential
from keras.layers import LSTM, Dense, Dropout
from sklearn.preprocessing import MinMaxScaler

# Check if 'Date' is already the index
if 'Date' not in data.columns:
    # If not, reset the index to include 'Date' as a column
    data = data.reset_index()
# Set 'Date' as the index
data.set_index('Date', inplace=True)

data.head()

# Use the 'Close' column for forecasting

time_series = data['Close']

time_series

# Visualize the time series

plt.figure(figsize=(10, 5))
plt.plot(time_series, label='Close Price')
plt.title('Stock Close Price Over Time')
plt.xlabel('Date')
plt.ylabel('Close Price')
plt.legend()
plt.show()

# Split data into training and testing sets

train_size = int(len(time_series) * 0.8)
train, test = time_series[:train_size], time_series[train_size:]

"""ARIMA MODEL"""

# Train ARIMA model

arima_model = ARIMA(train, order=(5, 1, 0))
arima_result = arima_model.fit()

# Forecasting

arima_forecast = arima_result.forecast(steps=len(test))

# Evaluate ARIMA
# Reset index of both test and arima_forecast
test_reset = test.reset_index(drop=True)
arima_forecast_reset = arima_forecast.reset_index(drop=True)

# Now you can directly use these reset series for RMSE calculation
# Remove NaN values from both series before calculating RMSE
test_reset = test_reset.dropna()
arima_forecast_reset = arima_forecast_reset.dropna()

# Ensure both series have the same length after removing NaNs
min_len = min(len(test_reset), len(arima_forecast_reset))
test_reset = test_reset[:min_len]
arima_forecast_reset = arima_forecast_reset[:min_len]

arima_rmse = np.sqrt(mean_squared_error(test_reset, arima_forecast_reset))
print(f'ARIMA RMSE : {arima_rmse}')

# Plotting

plt.figure(figsize=(10, 6))
plt.plot(test, label='Actual')
plt.plot(test.index, arima_forecast, label='ARIMA Forecast', color='green')
plt.title('ARIMA Forecast vs Actual')
plt.xlabel('Date')
plt.ylabel('Closing Price')
plt.legend()
plt.show()

"""SARIMA MODEL"""

# Training SARIMA model

sarima_model = SARIMAX(train, order=(1, 1, 1), seasonal_order=(1, 1, 1, 12))
sarima_result = sarima_model.fit()

# Forecasting

sarima_forecast = sarima_result.forecast(steps=len(test))

# Evaluate SARIMA
# Reset index of both test and arima_forecast
test_reset = test.reset_index(drop=True)
sarima_forecast_reset = sarima_forecast.reset_index(drop=True)

# Now you can directly use these reset series for RMSE calculation
# Remove NaN values from both series before calculating RMSE
test_reset = test_reset.dropna()
sarima_forecast_reset = sarima_forecast_reset.dropna()

# Ensure both series have the same length after removing NaNs
min_len = min(len(test_reset), len(sarima_forecast_reset))
test_reset = test_reset[:min_len]
sarima_forecast_reset = sarima_forecast_reset[:min_len]

sarima_rmse = np.sqrt(mean_squared_error(test_reset, sarima_forecast_reset))
print(f'SARIMA RMSE: {sarima_rmse}')

# Plotting

plt.figure(figsize=(10, 6))
plt.plot(test, label='Actual')
plt.plot(test.index, sarima_forecast, label='SARIMA Forecast', color='orange')
plt.title('SARIMA Forecast vs Actual')
plt.xlabel('Date')
plt.ylabel('Closing Price')
plt.legend()
plt.show()

"""PROPHET MODEL"""

# Prepare data for Prophet

prophet_data = data.reset_index()[['Date', 'Close']].rename(columns={'Date': 'ds', 'Close': 'y'})

# Train Prophet model

prophet_model = Prophet()
prophet_model.fit(prophet_data[:train_size])

# Forecastting

future = prophet_model.make_future_dataframe(periods=len(test))
forecast = prophet_model.predict(future)

# Evaluate Prophet

# Reset the index of the test series to a numerical index
test_reset = test.reset_index(drop=True)

# Now, use the reset test series to calculate RMSE
# Fill NaN values in 'yhat' column with 0 before calculating RMSE
forecast['yhat'] = forecast['yhat'].fillna(0)

# Remove NaN values from 'test_reset' before calculating RMSE
test_reset = test_reset.dropna()

# Ensure both series have the same length after removing NaNs
min_len = min(len(test_reset), len(forecast['yhat'][-len(test_reset):]))
test_reset = test_reset[:min_len]
forecast_yhat = forecast['yhat'][-len(test_reset):].reset_index(drop=True)[:min_len]

prophet_rmse = np.sqrt(mean_squared_error(test_reset, forecast_yhat))
print(f'Prophet RMSE: {prophet_rmse}')

# Plotting

prophet_model.plot(forecast)
plt.title('Prophet Forecast')
plt.xlabel('Date')
plt.ylabel('Closing Price')
plt.legend()
plt.show()

"""LSTM MODEL"""

# Normalize data for LSTM

scaler = MinMaxScaler(feature_range=(0, 1))
scaled_data = scaler.fit_transform(time_series.values.reshape(-1, 1))

# Create training and testing data

train_scaled = scaled_data[:train_size]
test_scaled = scaled_data[train_size:]

# Create sequences for LSTM

def create_sequences(data, seq_length):
    X, y = [], []
    for i in range(len(data) - seq_length):
        X.append(data[i:i+seq_length])
        y.append(data[i+seq_length])
    return np.array(X), np.array(y)

seq_length = 60
X_train, y_train = create_sequences(train_scaled, seq_length)
X_test, y_test = create_sequences(test_scaled, seq_length)

# Build LSTM model

lstm_model = Sequential([
    LSTM(50, return_sequences=True, input_shape=(seq_length, 1)),
    Dropout(0.2),
    LSTM(50, return_sequences=False),
    Dropout(0.2),
    Dense(1)
])

lstm_model.compile(optimizer='adam', loss='mean_squared_error')
lstm_model.fit(X_train, y_train, epochs=10, batch_size=32)

# Forecasting

lstm_forecast = lstm_model.predict(X_test)
lstm_forecast = scaler.inverse_transform(lstm_forecast)

# Evaluate LSTM

# Replace NaN values in lstm_forecast with 0
lstm_forecast = np.nan_to_num(lstm_forecast)

# Ensure both series have the same length after removing NaNs
min_len = min(len(test[-len(lstm_forecast):]), len(lstm_forecast))
test_data = test[-len(lstm_forecast):][:min_len]
lstm_forecast_data = lstm_forecast[:min_len]

# Remove or fill NaN values in test_data
test_data = test_data.fillna(method='ffill')  # Forward fill NaN values

# Calculate RMSE
lstm_rmse = np.sqrt(mean_squared_error(test_data, lstm_forecast_data))
print(f'LSTM RMSE: {lstm_rmse}')

# Plotting

plt.figure(figsize=(10, 6))
plt.plot(test[-len(lstm_forecast):], label='Actual')
plt.plot(test.index[-len(lstm_forecast):], lstm_forecast, label='LSTM Forecast', color='red')
plt.title('LSTM Forecast vs Actual')
plt.xlabel('Date')
plt.ylabel('Closing Price')
plt.legend()
plt.show()

# Compareing RMSE's for best model

models_rmse = {
    'ARIMA': arima_rmse,
    'SARIMA': sarima_rmse,
    'Prophet': prophet_rmse,
    'LSTM': lstm_rmse
}

best_model = min(models_rmse, key=models_rmse.get)
print(f'The best model is: {best_model} with RMSE = {models_rmse[best_model]:.2f}')

"""We build time series models using time series algorithms ARIMA,SARIMA,PROPHET and LSTM models and compared them for identifying best model.

LSTM Model given best forecast vs Actual forecast among other models with RSME:54.69.

"""

